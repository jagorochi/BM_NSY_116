enum Action {
  LOOK_FRONT_WAIT, LOOK_LEFT_WAIT, LOOK_RIGHT_WAIT, LOOK_UP_WAIT, 
    LOOK_FRONT_WALK, LOOK_LEFT_WALK, LOOK_RIGHT_WALK, LOOK_UP_WALK, 
    LOOK_FRONT_CARRY_WAIT, LOOK_LEFT_CARRY_WAIT, LOOK_RIGHT_CARRY_WAIT, LOOK_UP_CARRY_WAIT, 
    LOOK_FRONT_CARRY_WALK, LOOK_LEFT_CARRY_WALK, LOOK_RIGHT_CARRY_WALK, LOOK_UP_CARRY_WALK, 
    LOOK_FRONT_THROW, LOOK_LEFT_THROW, LOOK_RIGHT_THROW, LOOK_UP_THROW, 
    DIE, VICTORY, GROUND_APPEAR, GROUND_DISAPPEAR, TINY_DISAPPEAR;
  public static int COUNT = Action.values().length;
}

public class BomberMan {
  private ArrayList<PImage> lPlayerImages  = new ArrayList<PImage>();
  private int spriteWidth = 16;
  private int SpriteHeight = 32;
  private int totalSprite = 134;
  private boolean playerControl = false;
  private ArrayList<SpriteAnimation> lAnimation;
  private int xPos, yPos;

  public BomberMan(String strTileMapPath, int SpawnPosition) {
    PImage tileMapImg = loadImage(strTileMapPath);
    int TilePerWidth = tileMapImg.width / spriteWidth; // nombre max de tuile par ligne en fonction de la largeur en pixel de l'image tileMap
    /*  on va remplir d'image miniature "tuile" : lHardBlockTilesImages
     la tileMap à systematiquement une largeur en pixel égale à un multiple de la taille d'une tuile
     */
    int yDecal = 16*9; // les sprites de bomberman se trouve à une position plus basse dans l'image. (9 tuiles plus bas)
    for (int incr1 = 0; incr1 < totalSprite; incr1++) {
      int xSource = (incr1 % TilePerWidth) * spriteWidth; // position x et y dans l'image source tileMap
      int ySource = (floor(incr1 / TilePerWidth) * SpriteHeight) + yDecal;
      PImage i = createImage(spriteWidth, SpriteHeight, ARGB); // on crée une image a la volée avec un canal alpha
      i.copy(tileMapImg, xSource, ySource, spriteWidth, SpriteHeight, 0, 0, spriteWidth, SpriteHeight); // on copie le contenu
      lPlayerImages.add(i); // on stocke chaque miniature...
    }

    // on construit les animations
    for (int incr = 0; incr<Action.COUNT; incr++) {
      lAnimation.add(GetAnimation(Action.values()[incr]));
    }

    // spawn position
    // 95
    xPos = (SpawnPosition % 30 ) * 16;
    yPos = floor(SpawnPosition / 30) * 16;
  }

  public void display(Action t) {
  }


  public void SetPlayerControl(boolean bCtrl) {
    playerControl = bCtrl;
  }




  public void UpdatePosition() {
    /* mise a jour de l'affichage du personnage
     - en fonction de l'action en cours
     - en fonction du sprite de l'animation en cours
     - en fonction du décalage x et Y
     */
  }





  class Sprite {
    int TileID;
    int xDecal;
    int yDecal;
    int duration;
    public Sprite(int TileID, int xDecal, int yDecal, int duration) {
      this.TileID = TileID;
      this.xDecal = xDecal;
      this.yDecal = yDecal;
      this.duration = duration;
    }
  }

  class SpriteAnimation {
    int nbFrame = 0;
    int FrameLoop = 0;
    int[] framesPos;
    ArrayList<Sprite> sprites = new ArrayList<Sprite>();

    /*
    public SpriteAnimation() {
     } // Constructeur par défaut explicitement défini
     
     public SpriteAnimation(int FrameLoop) {
     this.FrameLoop = FrameLoop;
     }
     */
     
    public void setFrameLoop(int nSprite) { // défaut : boucle de la dernière vers la première
      if (nSprite == 0)
        FrameLoop = 0;
      else
        rebuildFramesTiming();
    }

    public void rebuildFramesTiming() {
      framesPos = new int[sprites.size()];
      int fDecal = 0;
      Sprite s;
      for (int incr = 0; incr < sprites.size(); incr++) {
        s = sprites.get(incr);
        framesPos[incr] = s.duration + fDecal;
        fDecal += s.duration;
      }
    }



    public void addSprite(int TileID, int xDecal, int yDecal, int duration) {
      sprites.add(new Sprite(TileID, xDecal, yDecal, duration));
    }
    public void addSprite(int TileID) {
      addSprite(TileID, 0, 0, 60);
    }
    public void addSprite(int TileID, int duration) {
      addSprite(TileID, 0, 0, duration);
    }
  }



  private SpriteAnimation GetAnimation(Action t) {
    SpriteAnimation s = new SpriteAnimation();
    switch (t) {
    case LOOK_FRONT_WAIT:
      s.addSprite(7);
      break;
    case LOOK_LEFT_WAIT:
      s.addSprite(10);
      break;
    case LOOK_RIGHT_WAIT:
      s.addSprite(4);
      break;
    case LOOK_UP_WAIT:
      s.addSprite(1);
      break;
    case LOOK_FRONT_WALK:
      s.addSprite(8, 10);
      s.addSprite(7, 10);
      s.addSprite(9, 10);
      s.addSprite(7, 10);
      break;
    case LOOK_LEFT_WALK:
      s.addSprite(11, 10);
      s.addSprite(10, 10);
      s.addSprite(12, 10);
      s.addSprite(10, 10);
      break;
    case LOOK_RIGHT_WALK:
      s.addSprite(5, 10);
      s.addSprite(4, 10);
      s.addSprite(6, 10);
      s.addSprite(4, 10);
      break;
    case LOOK_UP_WALK:
      s.addSprite(5, 10);
      s.addSprite(2, 10);
      s.addSprite(3, 10);
      s.addSprite(1, 10);
      break;
    case DIE:
      s.addSprite(37, 3);   // 4 spins !
      s.addSprite(39, 3);
      s.addSprite(14, 3);
      s.addSprite(38, 3);
      s.addSprite(37, 5);
      s.addSprite(39, 5);   //22
      s.addSprite(14, 5);
      s.addSprite(38, 5);   //32    
      s.addSprite(37, 7);
      s.addSprite(39, 8);
      s.addSprite(14, 9);   //56
      s.addSprite(38, 10);  //66 
      s.addSprite(37, 12);  //78
      s.addSprite(39, 15);  //93
      s.addSprite(14, 18);  //111
      s.addSprite(38, 20);  //131
      s.addSprite(40, 5);
      s.addSprite(41, 5);
      s.addSprite(42, 5);
      s.addSprite(43, 5);
      s.addSprite(42, 5);
      s.addSprite(44, 5);
      s.addSprite(42, 5);
      s.addSprite(43, 5);
      s.addSprite(42, 5);
      s.addSprite(44, 5);
      s.addSprite(42, 5);
      s.addSprite(43, 5);
      s.addSprite(42, 5);
      s.addSprite(44, 5);
      s.addSprite(42, 5);
      s.addSprite(43, 5);
      s.addSprite(42, 5);
      s.addSprite(44, 5);
      s.addSprite(42, 5);
      s.addSprite(41, 5);
      s.setFrameLoop(34);
      break;
    case VICTORY:
      s.addSprite(134, 60);
      s.addSprite(132, 10);
      s.addSprite(133, 10);
      s.addSprite(132, 10);
      s.addSprite(133, 10);
      s.addSprite(132, 10);
      s.addSprite(133, 60);
      break;
      // les animations suivantes ne sont pas détaillées pour le moment....
    case GROUND_APPEAR:
    case GROUND_DISAPPEAR:
    case TINY_DISAPPEAR:
    case LOOK_FRONT_CARRY_WAIT:
    case LOOK_LEFT_CARRY_WAIT:
    case LOOK_RIGHT_CARRY_WAIT:
    case LOOK_UP_CARRY_WAIT:
    case LOOK_FRONT_CARRY_WALK:
    case LOOK_LEFT_CARRY_WALK:
    case LOOK_RIGHT_CARRY_WALK:
    case LOOK_UP_CARRY_WALK:
    case LOOK_FRONT_THROW:
    case LOOK_LEFT_THROW:
    case LOOK_RIGHT_THROW:
    case LOOK_UP_THROW:
    default:
      s.addSprite(110);
      break;
    }
    s.rebuildFramesTiming();
    return s;
  }
}  